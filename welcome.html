<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1">
<title>Welcome to Ming Yang's Portfolio</title>
<base href="/portfolio/">
<link rel="stylesheet" href="styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600&display=swap" rel="stylesheet">
<style>
       @media (prefers-reduced-motion) {
           * {
               animation: none !important;
               transition: none !important;
           }
       }
</style>
</head>
<body>
<canvas id="three-canvas"></canvas>
<script type="module">
       import * as THREE from 'https://unpkg.com/three@0.168/build/three.module.js';
       import { FontLoader } from 'https://unpkg.com/three@0.168/examples/jsm/loaders/FontLoader.js';
       import { TextGeometry } from 'https://unpkg.com/three@0.168/examples/jsm/geometries/TextGeometry.js';
       import { OrbitControls } from 'https://unpkg.com/three@0.168/examples/jsm/controls/OrbitControls.js';
       import { EffectComposer } from 'https://unpkg.com/three@0.168/examples/jsm/postprocessing/EffectComposer.js';
       import { RenderPass } from 'https://unpkg.com/three@0.168/examples/jsm/postprocessing/RenderPass.js';
       import { UnrealBloomPass } from 'https://unpkg.com/three@0.168/examples/jsm/postprocessing/UnrealBloomPass.js';
       // Check for saved theme
       const theme = localStorage.getItem('theme');
       if (theme === 'dark') {
           document.body.classList.add('dark-mode');
       }
       const isDark = document.body.classList.contains('dark-mode');
       // Scene setup
       const scene = new THREE.Scene();
       scene.background = new THREE.Color(isDark ? 0x000000 : 0xffffff);
       scene.fog = new THREE.FogExp2(isDark ? 0x000000 : 0xffffff, 0.01);
       const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
       camera.position.set(0, 0, 50);
       const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
       renderer.setSize(window.innerWidth, window.innerHeight);
       renderer.setPixelRatio(window.devicePixelRatio);
       // Postprocessing
       const composer = new EffectComposer(renderer);
       const renderPass = new RenderPass(scene, camera);
       composer.addPass(renderPass);
       const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
       bloomPass.threshold = isDark ? 0 : 0.6;
       bloomPass.strength = isDark ? 1.2 : 0.8;
       bloomPass.radius = 0.1;
       composer.addPass(bloomPass);
       // Controls
       const controls = new OrbitControls(camera, renderer.domElement);
       controls.enableDamping = true;
       controls.dampingFactor = 0.05;
       // Lights
       const ambientLight = new THREE.AmbientLight(0xffffff, isDark ? 0.5 : 1);
       scene.add(ambientLight);
       const pointLight1 = new THREE.PointLight(0xff0000, isDark ? 1 : 0.8, 100);
       pointLight1.position.set(20, 20, 20);
       scene.add(pointLight1);
       const pointLight2 = new THREE.PointLight(0x00ff00, isDark ? 1 : 0.8, 100);
       pointLight2.position.set(-20, 20, 20);
       scene.add(pointLight2);
       const pointLight3 = new THREE.PointLight(0x0000ff, isDark ? 1 : 0.8, 100);
       pointLight3.position.set(0, -20, 20);
       scene.add(pointLight3);
       // Particles
       const particleCount = 10000;
       const positions = new Float32Array(particleCount * 3);
       const velocities = new Float32Array(particleCount * 3);
       const colors = new Float32Array(particleCount * 3);
       for (let i = 0; i < particleCount; i++) {
           positions[i * 3] = THREE.MathUtils.randFloatSpread(100);
           positions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(100);
           positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(100);
           velocities[i * 3] = THREE.MathUtils.randFloatSpread(0.5);
           velocities[i * 3 + 1] = THREE.MathUtils.randFloatSpread(0.5);
           velocities[i * 3 + 2] = THREE.MathUtils.randFloatSpread(0.5);
           const hue = i / particleCount;
           const color = new THREE.Color().setHSL(hue, 1, 0.5);
           colors[i * 3] = color.r;
           colors[i * 3 + 1] = color.g;
           colors[i * 3 + 2] = color.b;
       }
       const particleGeometry = new THREE.BufferGeometry();
       particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
       particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
       const particleMaterial = new THREE.PointsMaterial({
           size: 0.3,
           vertexColors: true,
           transparent: true,
           opacity: 0.8,
           blending: THREE.AdditiveBlending
       });
       const particles = new THREE.Points(particleGeometry, particleMaterial);
       scene.add(particles);
       // Mouse interaction
       const mouse = new THREE.Vector2();
       const attractor = new THREE.Vector3();
       const clickPosition = new THREE.Vector3();
       document.addEventListener('mousemove', (event) => {
           mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
           mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
           attractor.set(mouse.x, mouse.y, 0.5).unproject(camera);
       });
       // Load font and create enter button
       let enterText;
       const fontLoader = new FontLoader();
       fontLoader.load('https://unpkg.com/three@0.168/examples/fonts/helvetiker_regular.typeface.json', (font) => {
           const enterGeometry = new TextGeometry('Enter Portfolio', {
               font: font,
               size: 4,
               depth: 0.5,
               curveSegments: 12,
               bevelEnabled: true,
               bevelThickness: 0.3,
               bevelSize: 0.2,
               bevelSegments: 3
           });
           enterGeometry.center();
           const enterMaterial = new THREE.MeshStandardMaterial({
               color: isDark ? 0x9b59b6 : 0x7f8c8d,
               emissive: isDark ? 0x9b59b6 : 0x000000,
               emissiveIntensity: isDark ? 1 : 0,
               roughness: 0.4,
               metalness: 0.6
           });
           enterText = new THREE.Mesh(enterGeometry, enterMaterial);
           enterText.position.set(0, -20, 0);
           scene.add(enterText);
           // Raycaster for clicking enter text
           const raycaster = new THREE.Raycaster();
           function onClick(event) {
               mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
               mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
               raycaster.setFromCamera(mouse, camera);
               const intersects = raycaster.intersectObject(enterText);
               if (intersects.length > 0) {
                   window.location.href = 'index.html';
                   return;
               }
               // If not on button, explode particles from click point
               clickPosition.set(mouse.x, mouse.y, 0.5).unproject(camera);
               for (let i = 0; i < particleCount; i++) {
                   const px = positions[i * 3];
                   const py = positions[i * 3 + 1];
                   const pz = positions[i * 3 + 2];
                   const dx = px - clickPosition.x;
                   const dy = py - clickPosition.y;
                   const dz = pz - clickPosition.z;
                   const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                   if (dist < 20) {
                       const force = (20 - dist) / 20 * 2;
                       velocities[i * 3] += (dx / dist) * force;
                       velocities[i * 3 + 1] += (dy / dist) * force;
                       velocities[i * 3 + 2] += (dz / dist) * force;
                   }
               }
           }
           window.addEventListener('click', onClick);
       });
       // Animation loop
       let time = 0;
       function animate() {
           requestAnimationFrame(animate);
           time += 0.01;
           // Update particles
           for (let i = 0; i < particleCount; i++) {
               const px = positions[i * 3];
               const py = positions[i * 3 + 1];
               const pz = positions[i * 3 + 2];
               // Swirling motion
               velocities[i * 3] += Math.sin(time + py * 0.1) * 0.01;
               velocities[i * 3 + 1] += Math.cos(time + px * 0.1) * 0.01;
               // Attraction to mouse
               const dx = attractor.x - px;
               const dy = attractor.y - py;
               const dz = attractor.z - pz;
               const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
               if (dist > 0.1) {
                   velocities[i * 3] += (dx / dist) * 0.05;
                   velocities[i * 3 + 1] += (dy / dist) * 0.05;
                   velocities[i * 3 + 2] += (dz / dist) * 0.05;
               }
               // Damping
               velocities[i * 3] *= 0.98;
               velocities[i * 3 + 1] *= 0.98;
               velocities[i * 3 + 2] *= 0.98;
               // Update position
               positions[i * 3] += velocities[i * 3];
               positions[i * 3 + 1] += velocities[i * 3 + 1];
               positions[i * 3 + 2] += velocities[i * 3 + 2];
           }
           particleGeometry.attributes.position.needsUpdate = true;
           // Pulse enter button
           if (enterText) {
               const scale = 1 + Math.sin(time * 2) * 0.05;
               enterText.scale.set(scale, scale, scale);
           }
           // Update controls
           controls.update();
           composer.render();
       }
       animate();
       // Handle resize
       window.addEventListener('resize', () => {
           camera.aspect = window.innerWidth / window.innerHeight;
           camera.updateProjectionMatrix();
           renderer.setSize(window.innerWidth, window.innerHeight);
           composer.setSize(window.innerWidth, window.innerHeight);
       });
</script>
</body>
</html>